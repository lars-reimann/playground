

Here is one way this can be done: http://labs.codecademy.com/BHoF#:workspace
Explanation:
Order

The most natural way to go through the permutations is lexicographically. So let's say we want all permutations of "post". We would go through them systematically like this: opst, opts, ospt, ostp, otps, otsp, post, pots, psot, psto, ptos, ptso, sopt, sotp, spot, spto, stop, stpo, tops, tosp, tpos, tpso, tsop, tspo.

So the question reduces to finding the next permutation, when one is given. So for tops this would be tosp. As with numbers, we get smaller values by increasing the less significant places. So our best bet here is to swap the last two characters, which indeed give as the next permutation. But what about psto? Swapping the last two characters would yield a smaller word. So we have to look at the s and swap it with the smallest letter greater than s on its right hand side and we get ptso. Yet, this is not quite right. We also have to reverse the last two letter, because the next permutation is ptos. OK, but when do we have to do what?
Algorithm

def permutations(s):
    s = sorted(s)
    n = len(s)
    while True:

        # Visit
        print("".join(s))

        # Find first swap index
        i = n - 2
        while i >= 0 and s[i] >= s[i+1]:
            i -= 1

        # Last permutation visited
        if i < 0:
            return

        # Find second swap index
        j = n - 1
        while s[i] >= s[j]:
            j -= 1

        # Swap
        s[i], s[j] = s[j], s[i]

        # Reverse
        s[i+1:] = reversed(s[i+1:])

#Visit
Here we just print the current permutation.

#Find first swap index
The idea is to find the first letter from the right side that is less than its right neighbor. In our example above (psto) this is s, because t >= o and s < t. This is the first letter from the right side that can be increased. We do not care about anything to the left of s (when you want to find the next natural number after 9989, you do not care about 99 at the beginning either). So to say it again: s is at the position that is going to be increased later.

# Last permutation visited
If i < 0 here, that means s[0] >= s[1] >= s[2] >= ... >= s[n-2] >= s[n-1], so all letters are in reverse order. There cannot be any "larger" permutation and since we started with an ordered list and always computed the next permutation, we visited them all.

# Find second swap index
Remember, we have s[i+1] >= s[i+2] >= ... >= s[n-2] >= s[n-1], because otherwise our i would be different. We want to find a larger permutation and we already found the position we want to increase. Now we find its swapping partner. This is the smallest element on its right side that is greater than the element at position i. Again, we do not have to bother with the elements on its left side, these remain unchanged. Because of the inequalities above, we simply run through all the numbers from right to left, until we find a number that is greater. Because s[i] < s[i+1], we can be sure to find such an element.

# Swap
We now swap the elements at positions i and j. Because s[i+1] >= s[i+2] >= ... >= s[j] >= ...>= s[n-2] >= s[n-1] and s[j+1] <= s[i] < s[j], we have s[i+1] >= s[i+2] >= ... >= s[i] >= ...>= s[n-2] >= s[n-1]. So the letters from index i+1 up to n-1 are still in reverse order.

# Reverse
Because the letters from i+1 to n-1 are in reverse order, we have to reverse them to get the next permuation. This is a bit like going from 9099 to 9100. Because we increase something more to the left of the list, we have to make everything on the right side as small as possible.
Advice

The best way to understand this is by doing it yourself. Just grab a sheet of paper and follow the instructions in the algorithm a couple of times. It is more likely to make sense then, instead of just reading through my vague explanation.
References

The algorithm is taken from The Art of Computer Programming Vol. 4A (p. 319) by Donald E. Knuth.
